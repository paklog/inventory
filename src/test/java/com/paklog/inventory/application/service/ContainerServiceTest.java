package com.paklog.inventory.application.service;

import com.paklog.inventory.domain.model.Container;
import com.paklog.inventory.domain.model.ContainerStatus;
import com.paklog.inventory.domain.model.ContainerType;
import com.paklog.inventory.domain.model.Location;
import com.paklog.inventory.domain.model.LocationType;
import com.paklog.inventory.domain.repository.ContainerRepository;
import com.paklog.inventory.domain.repository.OutboxRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Tests for ContainerService - validates LPN/container management operations.
 * Tests container lifecycle, item management, nesting, and tracking.
 */
@ExtendWith(MockitoExtension.class)
class ContainerServiceTest {

    @Mock
    private ContainerRepository containerRepository;

    @Mock
    private OutboxRepository outboxRepository;

    @InjectMocks
    private ContainerService containerService;

    private Location testLocation;
    private String createdBy;

    @BeforeEach
    void setUp() {
        testLocation = Location.of("WH01", "A", "01", "01", "A", LocationType.GENERAL);
        createdBy = "USER-001";
    }

    @Test
    @DisplayName("Should create pallet container with auto-generated LPN")
    void shouldCreatePalletContainerWithAutoGeneratedLpn() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        when(containerRepository.save(any(Container.class))).thenReturn(container);

        // When
        String lpn = containerService.createContainer(ContainerType.PALLET, testLocation, createdBy);

        // Then
        assertNotNull(lpn);
        verify(containerRepository).save(any(Container.class));
    }

    @Test
    @DisplayName("Should create container with specific LPN")
    void shouldCreateContainerWithSpecificLpn() {
        // Given
        String customLpn = "LPN-CUSTOM-001";
        Container container = Container.createWithLPN(customLpn, ContainerType.CASE, testLocation, createdBy);

        when(containerRepository.existsByLpn(customLpn)).thenReturn(false);
        when(containerRepository.save(any(Container.class))).thenReturn(container);

        // When
        String lpn = containerService.createContainerWithLPN(
            customLpn, ContainerType.CASE, testLocation, createdBy
        );

        // Then
        assertEquals(customLpn, lpn);
        verify(containerRepository).save(any(Container.class));
    }

    @Test
    @DisplayName("Should throw exception when creating container with duplicate LPN")
    void shouldThrowExceptionWhenCreatingContainerWithDuplicateLpn() {
        // Given
        String duplicateLpn = "LPN-DUPLICATE";
        when(containerRepository.existsByLpn(duplicateLpn)).thenReturn(true);

        // When/Then
        assertThrows(IllegalArgumentException.class, () ->
            containerService.createContainerWithLPN(
                duplicateLpn, ContainerType.PALLET, testLocation, createdBy
            )
        );

        verify(containerRepository, never()).save(any());
    }

    @Test
    @DisplayName("Should add item to container")
    void shouldAddItemToContainer() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        String sku = "SKU-001";
        int quantity = 100;
        String lotNumber = "LOT-12345";

        // When
        containerService.addItem(container.getLpn(), sku, quantity, lotNumber, testLocation);

        // Then
        assertEquals(1, container.getItems().size());
        assertEquals(100, container.getTotalQuantity());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should add multiple items to create mixed-SKU container")
    void shouldAddMultipleItemsToCreateMixedSkuContainer() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When: Add multiple different SKUs
        containerService.addItem(container.getLpn(), "SKU-001", 100, "LOT-A", testLocation);
        containerService.addItem(container.getLpn(), "SKU-002", 50, "LOT-B", testLocation);
        containerService.addItem(container.getLpn(), "SKU-003", 75, "LOT-C", testLocation);

        // Then
        assertEquals(3, container.getItems().size());
        assertEquals(225, container.getTotalQuantity()); // 100 + 50 + 75
        assertTrue(container.isMixedSKU());
    }

    @Test
    @DisplayName("Should remove item from container")
    void shouldRemoveItemFromContainer() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        String sku = "SKU-001";
        String lotNumber = "LOT-12345";
        container.addItem(sku, 100, lotNumber, testLocation);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When: Remove partial quantity
        containerService.removeItem(container.getLpn(), sku, 30, lotNumber);

        // Then
        assertEquals(70, container.getTotalQuantity());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should throw exception when adding item to non-existent container")
    void shouldThrowExceptionWhenAddingItemToNonExistentContainer() {
        // Given
        when(containerRepository.findByLpn("INVALID-LPN")).thenReturn(Optional.empty());

        // When/Then
        assertThrows(IllegalArgumentException.class, () ->
            containerService.addItem("INVALID-LPN", "SKU-001", 100, "LOT-001", testLocation)
        );
    }

    @Test
    @DisplayName("Should move container to new location")
    void shouldMoveContainerToNewLocation() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Location newLocation = Location.of("WH01", "B", "05", "03", "C", LocationType.GENERAL);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        containerService.moveContainer(container.getLpn(), newLocation);

        // Then
        assertEquals(newLocation, container.getCurrentLocation());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should close container successfully")
    void shouldCloseContainerSuccessfully() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        container.addItem("SKU-001", 100, "LOT-001", testLocation);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        containerService.closeContainer(container.getLpn());

        // Then
        assertEquals(ContainerStatus.CLOSED, container.getStatus());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should ship closed container")
    void shouldShipClosedContainer() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        container.addItem("SKU-001", 100, "LOT-001", testLocation);
        container.close();

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        containerService.shipContainer(container.getLpn());

        // Then
        assertEquals(ContainerStatus.SHIPPED, container.getStatus());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should empty container and return to active status")
    void shouldEmptyContainerAndReturnToActiveStatus() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        container.addItem("SKU-001", 100, "LOT-001", testLocation);
        container.addItem("SKU-002", 50, "LOT-002", testLocation);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        containerService.emptyContainer(container.getLpn());

        // Then
        assertEquals(0, container.getItems().size());
        assertEquals(0, container.getTotalQuantity());
        assertEquals(ContainerStatus.ACTIVE, container.getStatus());
        verify(containerRepository).save(container);
    }

    @Test
    @DisplayName("Should nest container inside parent")
    void shouldNestContainerInsideParent() {
        // Given
        Container childContainer = Container.create(ContainerType.CASE, testLocation, createdBy);
        String parentLpn = "LPN-PARENT-001";

        when(containerRepository.findByLpn(childContainer.getLpn())).thenReturn(Optional.of(childContainer));
        when(containerRepository.existsByLpn(parentLpn)).thenReturn(true);

        // When
        containerService.nestContainer(childContainer.getLpn(), parentLpn);

        // Then
        assertEquals(parentLpn, childContainer.getParentLpn());
        verify(containerRepository).save(childContainer);
    }

    @Test
    @DisplayName("Should throw exception when nesting in non-existent parent")
    void shouldThrowExceptionWhenNestingInNonExistentParent() {
        // Given
        Container childContainer = Container.create(ContainerType.CASE, testLocation, createdBy);
        String invalidParentLpn = "INVALID-PARENT";

        when(containerRepository.findByLpn(childContainer.getLpn())).thenReturn(Optional.of(childContainer));
        when(containerRepository.existsByLpn(invalidParentLpn)).thenReturn(false);

        // When/Then
        assertThrows(IllegalArgumentException.class, () ->
            containerService.nestContainer(childContainer.getLpn(), invalidParentLpn)
        );
    }

    @Test
    @DisplayName("Should get container details")
    void shouldGetContainerDetails() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        Container result = containerService.getContainer(container.getLpn());

        // Then
        assertNotNull(result);
        assertEquals(container.getLpn(), result.getLpn());
        assertEquals(ContainerType.PALLET, result.getType());
    }

    @Test
    @DisplayName("Should throw exception when getting non-existent container")
    void shouldThrowExceptionWhenGettingNonExistentContainer() {
        // Given
        when(containerRepository.findByLpn("INVALID-LPN")).thenReturn(Optional.empty());

        // When/Then
        assertThrows(IllegalArgumentException.class, () ->
            containerService.getContainer("INVALID-LPN")
        );
    }

    @Test
    @DisplayName("Should get all active containers")
    void shouldGetAllActiveContainers() {
        // Given
        Container container1 = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Container container2 = Container.create(ContainerType.CASE, testLocation, createdBy);

        when(containerRepository.findActiveContainers()).thenReturn(List.of(container1, container2));

        // When
        List<Container> activeContainers = containerService.getActiveContainers();

        // Then
        assertEquals(2, activeContainers.size());
        assertTrue(activeContainers.stream().allMatch(c -> c.getStatus() == ContainerStatus.ACTIVE));
    }

    @Test
    @DisplayName("Should get containers by type")
    void shouldGetContainersByType() {
        // Given
        Container pallet1 = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Container pallet2 = Container.create(ContainerType.PALLET, testLocation, createdBy);

        when(containerRepository.findByType(ContainerType.PALLET))
            .thenReturn(List.of(pallet1, pallet2));

        // When
        List<Container> pallets = containerService.getContainersByType(ContainerType.PALLET);

        // Then
        assertEquals(2, pallets.size());
        assertTrue(pallets.stream().allMatch(c -> c.getType() == ContainerType.PALLET));
    }

    @Test
    @DisplayName("Should get containers at location")
    void shouldGetContainersAtLocation() {
        // Given
        Container container1 = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Container container2 = Container.create(ContainerType.CASE, testLocation, createdBy);

        when(containerRepository.findByLocation("WH01", "A"))
            .thenReturn(List.of(container1, container2));

        // When
        List<Container> containers = containerService.getContainersAtLocation("WH01", "A");

        // Then
        assertEquals(2, containers.size());
    }

    @Test
    @DisplayName("Should get child containers (nested)")
    void shouldGetChildContainersNested() {
        // Given
        String parentLpn = "LPN-PARENT-001";
        Container child1 = Container.create(ContainerType.CASE, testLocation, createdBy);
        Container child2 = Container.create(ContainerType.CASE, testLocation, createdBy);

        when(containerRepository.findByParentLpn(parentLpn))
            .thenReturn(List.of(child1, child2));

        // When
        List<Container> children = containerService.getChildContainers(parentLpn);

        // Then
        assertEquals(2, children.size());
    }

    @Test
    @DisplayName("Should get empty containers")
    void shouldGetEmptyContainers() {
        // Given
        Container emptyContainer1 = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Container emptyContainer2 = Container.create(ContainerType.CASE, testLocation, createdBy);

        when(containerRepository.findEmptyContainers())
            .thenReturn(List.of(emptyContainer1, emptyContainer2));

        // When
        List<Container> emptyContainers = containerService.getEmptyContainers();

        // Then
        assertEquals(2, emptyContainers.size());
        assertTrue(emptyContainers.stream().allMatch(c -> c.isEmpty()));
    }

    @Test
    @DisplayName("Should check if container is at capacity")
    void shouldCheckIfContainerIsAtCapacity() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        // Assume pallet max capacity is defined in domain model
        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        boolean atCapacity = containerService.isAtCapacity(container.getLpn());

        // Then
        assertFalse(atCapacity); // Empty container is not at capacity
    }

    @Test
    @DisplayName("Should check if container is mixed-SKU")
    void shouldCheckIfContainerIsMixedSku() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        container.addItem("SKU-001", 100, "LOT-A", testLocation);
        container.addItem("SKU-002", 50, "LOT-B", testLocation);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        boolean isMixed = containerService.isMixedSKU(container.getLpn());

        // Then
        assertTrue(isMixed);
    }

    @Test
    @DisplayName("Should count containers by status")
    void shouldCountContainersByStatus() {
        // Given
        when(containerRepository.countByStatus(ContainerStatus.ACTIVE)).thenReturn(15L);

        // When
        long count = containerService.countByStatus(ContainerStatus.ACTIVE);

        // Then
        assertEquals(15L, count);
    }

    @Test
    @DisplayName("Should count containers by type")
    void shouldCountContainersByType() {
        // Given
        when(containerRepository.countByType(ContainerType.PALLET)).thenReturn(50L);

        // When
        long count = containerService.countByType(ContainerType.PALLET);

        // Then
        assertEquals(50L, count);
    }

    @Test
    @DisplayName("Should handle complete container lifecycle")
    void shouldHandleCompleteContainerLifecycle() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        when(containerRepository.save(any(Container.class))).thenReturn(container);
        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When: Full lifecycle
        // 1. Create
        String lpn = containerService.createContainer(ContainerType.PALLET, testLocation, createdBy);
        assertEquals(ContainerStatus.ACTIVE, container.getStatus());

        // 2. Add items
        containerService.addItem(lpn, "SKU-001", 100, "LOT-001", testLocation);
        assertEquals(1, container.getItems().size());

        // 3. Close
        containerService.closeContainer(lpn);
        assertEquals(ContainerStatus.CLOSED, container.getStatus());

        // 4. Ship
        containerService.shipContainer(lpn);
        assertEquals(ContainerStatus.SHIPPED, container.getStatus());

        // Then: All state transitions completed
        verify(containerRepository, atLeast(4)).save(any(Container.class));
    }

    @Test
    @DisplayName("Should create different container types")
    void shouldCreateDifferentContainerTypes() {
        // Given
        Container pallet = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Container caseContainer = Container.create(ContainerType.CASE, testLocation, createdBy);
        Container tote = Container.create(ContainerType.TOTE, testLocation, createdBy);
        Container carton = Container.create(ContainerType.CARTON, testLocation, createdBy);

        when(containerRepository.save(any(Container.class)))
            .thenReturn(pallet)
            .thenReturn(caseContainer)
            .thenReturn(tote)
            .thenReturn(carton);

        // When
        String lpn1 = containerService.createContainer(ContainerType.PALLET, testLocation, createdBy);
        String lpn2 = containerService.createContainer(ContainerType.CASE, testLocation, createdBy);
        String lpn3 = containerService.createContainer(ContainerType.TOTE, testLocation, createdBy);
        String lpn4 = containerService.createContainer(ContainerType.CARTON, testLocation, createdBy);

        // Then
        assertNotNull(lpn1);
        assertNotNull(lpn2);
        assertNotNull(lpn3);
        assertNotNull(lpn4);
        verify(containerRepository, times(4)).save(any(Container.class));
    }

    @Test
    @DisplayName("Should track container movement history")
    void shouldTrackContainerMovementHistory() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        Location location2 = Location.of("WH01", "B", "03", "02", "A", LocationType.GENERAL);
        Location location3 = Location.of("WH01", "C", "10", "05", "B", LocationType.GENERAL);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When: Move container multiple times
        containerService.moveContainer(container.getLpn(), location2);
        containerService.moveContainer(container.getLpn(), location3);

        // Then
        assertEquals(location3, container.getCurrentLocation());
        verify(containerRepository, times(2)).save(container);
    }

    @Test
    @DisplayName("Should validate single-SKU container")
    void shouldValidateSingleSkuContainer() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        container.addItem("SKU-001", 100, "LOT-A", testLocation);
        container.addItem("SKU-001", 50, "LOT-B", testLocation); // Same SKU, different lot

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When
        boolean isMixed = containerService.isMixedSKU(container.getLpn());

        // Then
        assertFalse(isMixed); // Same SKU, different lots = not mixed
    }

    @Test
    @DisplayName("Should handle partial item removal")
    void shouldHandlePartialItemRemoval() {
        // Given
        Container container = Container.create(ContainerType.PALLET, testLocation, createdBy);
        String sku = "SKU-001";
        String lotNumber = "LOT-001";
        container.addItem(sku, 200, lotNumber, testLocation);

        when(containerRepository.findByLpn(container.getLpn())).thenReturn(Optional.of(container));

        // When: Remove partial quantity multiple times
        containerService.removeItem(container.getLpn(), sku, 50, lotNumber);
        assertEquals(150, container.getTotalQuantity());

        containerService.removeItem(container.getLpn(), sku, 75, lotNumber);
        assertEquals(75, container.getTotalQuantity());

        // Then
        assertEquals(75, container.getTotalQuantity());
        verify(containerRepository, times(2)).save(container);
    }
}
